import { fileURLToPath } from "url";
import { Duration, Stack, type StackProps } from "aws-cdk-lib";
import { Certificate } from "aws-cdk-lib/aws-certificatemanager";
import {
    InstanceClass,
    InstanceSize,
    InstanceType,
    IpAddresses,
    IpProtocol,
    SubnetType,
    Vpc,
} from "aws-cdk-lib/aws-ec2";
import { DockerImageAsset } from "aws-cdk-lib/aws-ecr-assets";
import { Cluster, ContainerImage } from "aws-cdk-lib/aws-ecs";
import { ApplicationLoadBalancedFargateService } from "aws-cdk-lib/aws-ecs-patterns";
import { Effect, PolicyStatement, Role, ServicePrincipal } from "aws-cdk-lib/aws-iam";
import {
    AuroraPostgresEngineVersion,
    ClientPasswordAuthType,
    Credentials,
    DatabaseCluster,
    DatabaseClusterEngine,
    DatabaseProxy,
    ProxyTarget,
} from "aws-cdk-lib/aws-rds";
import { ClusterInstance } from "aws-cdk-lib/aws-rds";
import type { Construct } from "constructs";

type ApiStackProps = StackProps & {
    apiEnv: string;
    certificateArn: string;
};

export class ApiStack extends Stack {
    public constructor(scope: Construct, id: string, props: ApiStackProps) {
        super(scope, id, props);

        const vpc = new Vpc(this, "Vpc", {
            ipProtocol: IpProtocol.DUAL_STACK,
            ipAddresses: IpAddresses.cidr("172.10.0.0/16"),
            subnetConfiguration: [
                {
                    name: "Public",
                    subnetType: SubnetType.PUBLIC,
                },
{{#if (has features "postgres")}}
                {
                    name: "PrivateIsolated",
                    subnetType: SubnetType.PRIVATE_ISOLATED,
                },
{{/if}}
            ],
            maxAzs: 2,
        });
{{#if (has features "postgres")}}

        const databaseCluster = new DatabaseCluster(this, "Database", {
            vpc,
            vpcSubnets: { subnetType: SubnetType.PRIVATE_ISOLATED },
            engine: DatabaseClusterEngine.auroraPostgres({
                version: AuroraPostgresEngineVersion.VER_16_0,
            }),
            credentials: Credentials.fromGeneratedSecret("api"),
            writer: ClusterInstance.provisioned("DatabaseWriter", {
                instanceType: InstanceType.of(InstanceClass.BURSTABLE3, InstanceSize.MEDIUM),
                autoMinorVersionUpgrade: true,
                allowMajorVersionUpgrade: true,
            }),
            defaultDatabaseName: "api",
            backup: {
                retention: Duration.days(21),
                // 1am to 2am west coast, 4am to 5am east coast
                preferredWindow: '09:00-10:00',
            },
        });

        if (!databaseCluster.secret) {
            throw new Error("Database cluster has nio secret attached");
        }

        const databaseProxy = new DatabaseProxy(this, "DatabaseProxy", {
            vpc,
            proxyTarget: ProxyTarget.fromCluster(databaseCluster),
            secrets: [databaseCluster.secret],
            clientPasswordAuthType: ClientPasswordAuthType.POSTGRES_SCRAM_SHA_256,
        });
{{/if}}
{{#if (has features "appconfig")}}

        const appConfig = new AppConfig(this, "AppConfig", {
            name: `{{{apiName}}}-${props.apiEnv}`,
        });
{{/if}}

        const cluster = new Cluster(this, "Cluster", {
            vpc,
        });

        const buildkitCachePath = process.env.BUILDKIT_CACHE_PATH;
        const asset = new DockerImageAsset(this, "App", {
            directory: fileURLToPath(new URL("../../", import.meta.url)),
            cacheTo: buildkitCachePath
                ? {
                      type: "local",
                      params: {
                          mode: "max",
                          "image-manifest": "true",
                          "oci-mediatypes": "true",
                          dest: buildkitCachePath,
                      },
                  }
                : undefined,
            cacheFrom: buildkitCachePath
                ? [
                      {
                          type: "local",
                          params: {
                              src: buildkitCachePath,
                          },
                      },
                  ]
                : undefined,
            outputs: ["type=docker"],
            exclude: ["cdk"],
        });

        const certificate = Certificate.fromCertificateArn(
            this,
            "Certificate",
            props.certificateArn,
        );

        const taskRole = new Role(this, "TaskRole", {
            assumedBy: new ServicePrincipal("ecs-tasks.amazonaws.com"),
        });
{{#if (has features "postgres")}}

        databaseCluster.secret.grantRead(taskRole);
{{/if}}
{{#if (has features "appconfig")}}

        appConfig.grantRead(taskRole);
{{/if}}

        const albService = new ApplicationLoadBalancedFargateService(this, "Service", {
            cluster,
            cpu: 512,
            memoryLimitMiB: 1024,
            taskImageOptions: {
                containerName: "app",
                containerPort: 80,
                image: ContainerImage.fromDockerImageAsset(asset),
                environment: {
                    PORT: "80",
{{#if (has features "postgres")}}
                    POSTGRES_HOSTNAME: databaseProxy.endpoint,
                    POSTGRES_PORT: databaseCluster.clusterEndpoint.port.toString(),
                    POSTGRES_SECRET: databaseCluster.secret.secretArn,
{{/if}}
{{#if (has features "appconfig")}}
                    APPCONFIG_APPLICATION_IDENTIFIER: appConfig.applicationId,
                    APPCONFIG_ENVIRONMENT_IDENTIFIER: appConfig.environmentId,
                    APPCONFIG_CONFIGURATION_PROFILE_IDENTIFIER: appConfig.configurationProfileId,
{{/if}}
                },
                taskRole,
            },
            certificate: certificate,
            assignPublicIp: true,
            publicLoadBalancer: true,
            healthCheckGracePeriod: Duration.seconds(10),
        });

        const serviceScaling = albService.service.autoScaleTaskCount({ maxCapacity: 10 });
        serviceScaling.scaleOnCpuUtilization("ScalingCpu", {
            targetUtilizationPercent: 60,
        });

        albService.targetGroup.setAttribute("deregistration_delay.timeout_seconds", "30");

        albService.targetGroup.configureHealthCheck({
            enabled: true,
            path: "/health",
        });
    }
}
